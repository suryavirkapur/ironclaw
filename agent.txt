current context:
- implemented security layer in `ironclawd` with a new `crates/security` crate
- added gateway pairing flow with sqlite-backed otp lifecycle and bearer token validation
- websocket can require gateway node id + bearer token when `gateway.pairing.enabled = true`
- added sliding-window rate limiting backed by sqlite and wired checks into websocket,
  telegram, whatsapp, webhook, and gateway api handlers
- added channel allowlist and webhook secret auth gate enforcement

pending tasks:
- decide whether to add an `openclaw` binary alias that proxies `gateway pair/status`
- evaluate and fix flaky/hanging `daemon_exits_on_sigterm_and_cleans_pid_file` behavior in this environment
- add external e2e coverage for gateway pairing endpoints with real http client flows

important decisions:
- kept pairing and rate limiting in a dedicated crate (`crates/security`) for reuse and isolation
- stored bearer tokens hashed (`sha256`) while keeping otp values transient and cleared after pairing
- used constant-time comparisons for otp and webhook/bearer secret checks
- applied rate limiting at ingress points before request handling rather than after processing

architectural notes:
- security sqlite db path is host-scoped at `users_root/security.db`
- pairing schema includes required columns plus bearer hash metadata
- rate limiter uses second-level buckets in `rate_limits` for sliding minute/hour sums
- webhook auth uses header `x-webhook-secret`; optional user id for limits uses `x-user-id`

plan:
- monitor runtime behavior and tune default limits if production traffic patterns require it
- add metrics export around rate-limit and auth-denied events if observability scope increases

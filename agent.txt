current context:
- host now runs soul guard monitoring with sqlite audit + approval queue:
  - monitored paths: `/mnt/brain/soul.md` and `users_root/<user>/guest/soul.md`
  - suspicious thresholds: `>1024` bytes diff or `>20%` change ratio
  - queue + logs in `users_root/soul_guard.db`
- host exposes soul guard api:
  - `GET /api/soul-guard/pending`
  - `POST /api/soul-guard/decision` (`approve`/`reject`)
- websocket handling now enforces a security halt when pending soul approvals exist
- guest runtime now includes a background cron scheduler:
  - jobs source: `/mnt/brain/cron/jobs.toml`
  - results log sink: `/mnt/brain/logs/YYYY-MM-DD.md`
  - sqlite mirror table: `scheduler_state` (`last_run_ms`, `next_run_ms`, `status`)

pending tasks:
- rerun websocket smoke scripts on a host where tcp bind is permitted (current sandbox blocks bind)
- validate soul guard api from ui integration flow
- run manual firecracker and telegram/whatsapp e2e flows on a host with required runtime permissions

important decisions:
- used host sqlite queue (`users_root/soul_guard.db`) for approvals instead of queue files
- applied a polling soul monitor loop (2s tick) to avoid platform-specific fs watch dependencies
- implemented internal 5-field cron parsing in guest to keep builds working offline
- wrote scheduler state to the existing guest sqlite db path for ui read models

architectural notes:
- soul guard logs every detected `soul.md` diff with hash before/after and suspicion metadata
- pending soul approvals are deduped by `(path, after_hash, status='pending')`
- scheduler cron matcher supports numeric fields and `*` only (5-field cron)
- scheduler stores log file reference (`last_result_ref`) for ui navigation

plan:
- validate websocket + api integration against ui workflows
- evaluate extended cron grammar support (`*/n`, ranges, lists) if needed by product requirements

current context:
- cron jobtrigger host handling now wakes sleeping guest agents, runs scheduled jobs, and sends jobstatus with debug traces
- vm manager now exposes `is_vm_running(user_id)` and host logs vm lookup state before spawn/start
- channel ingress now resolves owner-keyed identity across websocket, telegram, and whatsapp
- whatsapp now uses guest transport lifecycle with vm check/start, auth, wake/sleep, vsock forwarding, and streamed deltas
- integration tests cover cron-trigger wake/run/status and channel owner identity routing

pending tasks:
- rerun websocket smoke scripts on a host where tcp bind is permitted (current sandbox blocks bind)
- validate soul guard api from ui integration flow
- run manual firecracker and telegram/whatsapp e2e flows on a host with required runtime permissions

important decisions:
- kept owner identity canonical for telegram/whatsapp as `owner`; websocket keeps explicit `user_id`
- reused existing guest `run_scheduled_job` tool path to execute cron work after host-trigger orchestration
- aligned whatsapp guest-mode behavior with telegram/websocket wake-forward-stream semantics

architectural notes:
- jobtrigger flow: guest scheduler emits trigger -> host wakes agent (if sleeping) -> host requests `run_scheduled_job` -> host sends `jobstatus`
- channel flow: ingress -> resolve owner identity -> vm running check -> transport ensure -> wake (if sleeping) -> vsock send/recv stream
- guest sleep state remains session-tracked and controlled via explicit `agentcontrol` messages

plan:
- run full integration smoke for websocket + telegram + whatsapp routing against firecracker runtime
- evaluate cross-channel single-transport coordination if concurrent owner traffic needs stronger vm reuse guarantees

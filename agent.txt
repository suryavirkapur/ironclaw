current context:
- host channel routing now uses a shared owner identity resolver across websocket, telegram, and whatsapp ingress
- cron jobtrigger handling now traces full flow and explicitly wakes sleeping guest agents before scheduled execution
- whatsapp path now supports guest transport lifecycle (vm check/start, auth, wake, vsock forwarding, stream delta handling)
- vm manager now exposes `is_vm_running(user_id)`; host logs vm running state before spawn
- integration tests cover cron-trigger wake/run/status behavior and owner identity routing across channels

pending tasks:
- rerun websocket smoke scripts on a host where tcp bind is permitted (current sandbox blocks bind)
- validate soul guard api from ui integration flow
- run manual firecracker and telegram/whatsapp e2e flows on a host with required runtime permissions

important decisions:
- kept agent ownership keyed by user identity (`owner` for telegram/whatsapp, explicit `user_id` for websocket)
- reused existing guest job execution contract (`run_scheduled_job`) and wrapped it in host-side trigger orchestration with debug logs
- aligned whatsapp with telegram guest-mode semantics instead of keeping host-only execution

architectural notes:
- jobtrigger flow is now: guest scheduler emits trigger -> host wake if sleeping -> host sends `run_scheduled_job` -> host emits `jobstatus`
- channel message flow is now: ingress identity resolve -> vm running check/log -> transport ensure -> wake if needed -> vsock send/recv stream
- guest sleep state is tracked per channel session and transitioned by explicit `agentcontrol` messages

plan:
- run full integration smoke for websocket + telegram + whatsapp routing against firecracker runtime
- add cross-channel single-transport session coordination if concurrent owner traffic requires avoiding vm restarts
